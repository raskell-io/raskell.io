<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>Raskell</title>
      <link>https://raskell.io</link>
      <description>Writing about platform automation, edge systems, applied security, and open standards. Building automation-first platforms that survive production reality.</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://raskell.io/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Sun, 14 Dec 2025 00:00:00 +0000</lastBuildDate>
      <item>
          <title>Mise ate my Makefile</title>
          <pubDate>Sun, 14 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://raskell.io/articles/mise-ate-my-makefile/</link>
          <guid>https://raskell.io/articles/mise-ate-my-makefile/</guid>
          <description xml:base="https://raskell.io/articles/mise-ate-my-makefile/">&lt;h2 id=&quot;the-problem-with-project-setup&quot;&gt;The problem with project setup&lt;&#x2F;h2&gt;
&lt;p&gt;Every project starts the same. You need Ruby 3.2.1 but have 2.7. You need Node 20 but have 18. Someone wrote a Makefile that assumes GNU make but you’re on BSD. The &lt;code&gt;scripts&#x2F;&lt;&#x2F;code&gt; folder has 47 shell scripts and nobody remembers what half of them do.&lt;&#x2F;p&gt;
&lt;p&gt;I found mise. It fixed all of this.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-mise-actually-is&quot;&gt;What mise actually is&lt;&#x2F;h2&gt;
&lt;p&gt;mise started as a Rust rewrite of asdf. Then it absorbed make’s job too. Now it’s the one tool I install on every machine.&lt;&#x2F;p&gt;
&lt;p&gt;Here’s what my typical project setup looked like before:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.ruby-version&lt;&#x2F;code&gt; for rbenv&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;.nvmrc&lt;&#x2F;code&gt; for node&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Makefile&lt;&#x2F;code&gt; with 20 targets&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;scripts&#x2F;&lt;&#x2F;code&gt; with random shell scripts&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;.env.example&lt;&#x2F;code&gt; that nobody updates&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Here’s what it looks like now:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# .mise.toml
&lt;&#x2F;span&gt;&lt;span&gt;[tools]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;ruby &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;3.2.1&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;node &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;20.11.0&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;python &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;3.12&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[tasks&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;test]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;run &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;bundle exec rspec &amp;amp;&amp;amp; npm test&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;description &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Run all tests&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[tasks&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;deploy]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;run &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;kubectl apply -f k8s&#x2F;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;depends &lt;&#x2F;span&gt;&lt;span&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;test&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;build&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;[env]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;DATABASE_URL &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;postgresql:&#x2F;&#x2F;localhost&#x2F;myapp_dev&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;RAILS_ENV &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;development&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;One file. Everything works.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-fuzzy-matching-that-actually-works&quot;&gt;The fuzzy matching that actually works&lt;&#x2F;h2&gt;
&lt;p&gt;This is where mise gets interesting. You don’t need exact command names.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; mise run test     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# runs the test task
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; mise run tset     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# still runs test (typo forgiven)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; mise run tst      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# yep, runs test
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; mise run deploy   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# runs deploy task
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; mise run dply     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# runs deploy
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The fuzzy matching is smart. It weighs:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Character position (earlier matches score higher)&lt;&#x2F;li&gt;
&lt;li&gt;Consecutive matches&lt;&#x2F;li&gt;
&lt;li&gt;Word boundaries&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I tested this with 30+ tasks in one project. It still found the right one 90% of the time with 3-4 characters.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tasks-live-where-they-should&quot;&gt;Tasks live where they should&lt;&#x2F;h2&gt;
&lt;p&gt;Instead of polluting the root with &lt;code&gt;scripts&#x2F;&lt;&#x2F;code&gt;, mise looks in &lt;code&gt;.mise&#x2F;tasks&#x2F;&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;.mise&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;└──&lt;&#x2F;span&gt;&lt;span&gt; tasks&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;├──&lt;&#x2F;span&gt;&lt;span&gt; db-reset.sh
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;├──&lt;&#x2F;span&gt;&lt;span&gt; cache-clear.sh
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;└──&lt;&#x2F;span&gt;&lt;span&gt; logs-tail.sh
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Any executable in there becomes a task. No registration. No config.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; mise run db-reset    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# runs .mise&#x2F;tasks&#x2F;db-reset.sh
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; mise run cache       &lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# fuzzy matches to cache-clear.sh
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Shell scripts stay shell scripts. But now they’re discoverable:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; mise tasks
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;cache-clear&lt;&#x2F;span&gt;&lt;span&gt;   Clear all caches
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;db-reset&lt;&#x2F;span&gt;&lt;span&gt;      Reset database to clean state  
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;logs-tail&lt;&#x2F;span&gt;&lt;span&gt;     Tail production logs
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;          Run all tests
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;deploy&lt;&#x2F;span&gt;&lt;span&gt;        Deploy to production
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;the-encryption-bit-that-matters&quot;&gt;The encryption bit that matters&lt;&#x2F;h2&gt;
&lt;p&gt;mise includes age encryption support. Not bolted on. Built in.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# .mise.toml
&lt;&#x2F;span&gt;&lt;span&gt;[env]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;DATABASE_URL &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;postgresql:&#x2F;&#x2F;localhost&#x2F;dev&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;API_KEY &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;age:SECRET_ENCRYPTED_STRING&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Set it up once:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; mise decrypt .mise.toml
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;Enter&lt;&#x2F;span&gt;&lt;span&gt; passphrase: 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; export API_KEY=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;actual-secret-key&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; mise encrypt .mise.toml
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Your secrets are in the repo but encrypted. CI&#x2F;CD gets the age key. Developers get the age key. Random GitHub scrapers get nothing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;integration-with-zed&quot;&gt;Integration with Zed&lt;&#x2F;h2&gt;
&lt;p&gt;This is where it gets smooth. In Zed, I set up task shortcuts:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;&#x2F;&#x2F; .zed&#x2F;tasks.json
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;tasks&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;test&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;command&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;mise run test&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;cwd&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;$WORKSPACE_ROOT&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    }&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;deploy&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;command&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;mise run deploy&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;cwd&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;$WORKSPACE_ROOT&amp;quot;  
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now &lt;code&gt;cmd-shift-t&lt;&#x2F;code&gt; opens the task picker. Type “te”, hit enter. Tests run. The AI assistant sees the output inline. Fixes the code. Reruns the test. No context switching.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-breaks&quot;&gt;What breaks&lt;&#x2F;h2&gt;
&lt;p&gt;mise isn’t perfect. Here’s what I hit:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Windows support&lt;&#x2F;strong&gt;: Works through WSL. Native is rough.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Legacy tools&lt;&#x2F;strong&gt;: Some older ruby&#x2F;node versions don’t install clean. Same issue asdf has.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Task dependencies&lt;&#x2F;strong&gt;: Can’t do dynamic dependencies like make. Tasks depend on fixed task names.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Fuzzy matching confusion&lt;&#x2F;strong&gt;: With tasks named &lt;code&gt;deploy-staging&lt;&#x2F;code&gt; and &lt;code&gt;deploy-production&lt;&#x2F;code&gt;, typing &lt;code&gt;deploy&lt;&#x2F;code&gt; might pick wrong. Be specific or rename.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;the-tradeoffs&quot;&gt;The tradeoffs&lt;&#x2F;h2&gt;
&lt;p&gt;What I gained:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;One tool instead of 4 (asdf, direnv, make, scripts)&lt;&#x2F;li&gt;
&lt;li&gt;Fuzzy matching saves 100s of keystrokes daily&lt;&#x2F;li&gt;
&lt;li&gt;New devs get running in 2 commands: &lt;code&gt;mise install&lt;&#x2F;code&gt; and &lt;code&gt;mise run setup&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Secrets management that doesn’t suck&lt;&#x2F;li&gt;
&lt;li&gt;Task discovery that actually works&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;What I paid:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Another tool to install (but it replaces 4)&lt;&#x2F;li&gt;
&lt;li&gt;TOML syntax (not everyone’s favorite)&lt;&#x2F;li&gt;
&lt;li&gt;Rewriting Makefiles (took an afternoon per project)&lt;&#x2F;li&gt;
&lt;li&gt;Teaching the team new patterns (took a week)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;migration-pattern&quot;&gt;Migration pattern&lt;&#x2F;h2&gt;
&lt;p&gt;If you’re moving an existing project:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Install mise: &lt;code&gt;curl https:&#x2F;&#x2F;mise.jdx.dev&#x2F;install.sh | sh&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Import existing tool versions: &lt;code&gt;mise install&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Move one make target at a time to mise tasks&lt;&#x2F;li&gt;
&lt;li&gt;Move scripts to &lt;code&gt;.mise&#x2F;tasks&#x2F;&lt;&#x2F;code&gt; gradually&lt;&#x2F;li&gt;
&lt;li&gt;Add encryption last (less disruption)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Start with the most-used tasks. Leave the weird legacy stuff in make until later.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-i-d-do-differently&quot;&gt;What I’d do differently&lt;&#x2F;h2&gt;
&lt;p&gt;After migrating 12 projects:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Start with &lt;code&gt;.mise.toml&lt;&#x2F;code&gt;, not &lt;code&gt;.mise&#x2F;config.yaml&lt;&#x2F;code&gt;. TOML is cleaner for this.&lt;&#x2F;li&gt;
&lt;li&gt;Put all tasks in &lt;code&gt;.mise&#x2F;tasks&#x2F;&lt;&#x2F;code&gt; as shell scripts first. Move to inline tasks only when needed.&lt;&#x2F;li&gt;
&lt;li&gt;Name tasks with clear prefixes: &lt;code&gt;db-reset&lt;&#x2F;code&gt;, &lt;code&gt;cache-clear&lt;&#x2F;code&gt;, &lt;code&gt;test-unit&lt;&#x2F;code&gt;. Makes fuzzy matching more predictable.&lt;&#x2F;li&gt;
&lt;li&gt;Document the age key setup immediately. People forget.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;the-bottom-line&quot;&gt;The bottom line&lt;&#x2F;h2&gt;
&lt;p&gt;mise replaced my entire project automation stack. The Rust rewrite isn’t just faster. It’s more thoughtful. Fuzzy matching, encrypted env vars, task discovery. These aren’t features. They’re fixes for real pain.&lt;&#x2F;p&gt;
&lt;p&gt;Every new project starts with &lt;code&gt;.mise.toml&lt;&#x2F;code&gt; now. Setup takes 5 minutes instead of an hour. New developers don’t message me asking how to run tests. They just run &lt;code&gt;mise tasks&lt;&#x2F;code&gt; and figure it out.&lt;&#x2F;p&gt;
&lt;p&gt;That’s the tool working.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Disk space maintenance on Void Linux</title>
          <pubDate>Wed, 01 May 2024 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://raskell.io/articles/disk-space-void-linux-maintenance/</link>
          <guid>https://raskell.io/articles/disk-space-void-linux-maintenance/</guid>
          <description xml:base="https://raskell.io/articles/disk-space-void-linux-maintenance/">&lt;h2 id=&quot;monday-morning-surprise&quot;&gt;Monday morning surprise&lt;&#x2F;h2&gt;
&lt;p&gt;As I spent most time doing stuff with my computer rather than configuring my beloved Linux distribution, Void Linux, I have developed the tendency to not really bother about Void at all until something crucial becomes unusable. After almost two years of having switched from Arch to Void, I have actually never encountered any major problem and felt I had made the right decision.&lt;&#x2F;p&gt;
&lt;p&gt;I checked my disk usage out of curiosity if the 250GB solid-state disk would be enough. And there came the surprise:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;shell&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-shell &quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span&gt;$ df -H
&lt;&#x2F;span&gt;&lt;span&gt;Filesystem      Size  Used Avail Use% Mounted on
&lt;&#x2F;span&gt;&lt;span&gt;devtmpfs        8.4G     0  8.4G   0% &#x2F;dev
&lt;&#x2F;span&gt;&lt;span&gt;tmpfs           8.4G  1.9M  8.4G   1% &#x2F;dev&#x2F;shm
&lt;&#x2F;span&gt;&lt;span&gt;tmpfs           8.4G  1.4M  8.4G   1% &#x2F;run
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;dev&#x2F;nvme0n1p3  138G  117G   21G  85% &#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;efivarfs        158k   85k   69k  56% &#x2F;sys&#x2F;firmware&#x2F;efi&#x2F;efivars
&lt;&#x2F;span&gt;&lt;span&gt;cgroup          8.4G     0  8.4G   0% &#x2F;sys&#x2F;fs&#x2F;cgroup
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;dev&#x2F;nvme0n1p4  366G   34G  332G  10% &#x2F;home
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;dev&#x2F;nvme0n1p1  536M  152k  536M   1% &#x2F;boot&#x2F;efi
&lt;&#x2F;span&gt;&lt;span&gt;tmpfs           8.4G   25k  8.4G   1% &#x2F;tmp
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;My root partition was full, way too full in my opinion. Did I miss something? Is Void not what I was looking for after all? I don’t enjoy baby sitting my OS &lt;em&gt;du jour&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-painless-solution&quot;&gt;The painless solution&lt;&#x2F;h2&gt;
&lt;p&gt;After a quick Brave search, I ended up finding what I was looking for. Some kind fellow software engineer from China didn’t shy away to make a blog post about his journey when he faced the very same problem. Out of annoyance of having to deal with that, I copy-pasted as quickly as possible, not minding what kind of side-effects I might run into, these three commands.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;1-cleaning-the-package-cache&quot;&gt;1. Cleaning the package cache&lt;&#x2F;h3&gt;
&lt;p&gt;All the knowledge I was lacking was to be found with the man page of &lt;code&gt;xbps-remove&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;shell&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-shell &quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span&gt;# xbps-remove -yO
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;man.voidlinux.org&#x2F;xbps-remove.1#O,&quot;&gt;man page&lt;&#x2F;a&gt; of &lt;code&gt;xbps-remove&lt;&#x2F;code&gt; tells us the &lt;code&gt;-O&lt;&#x2F;code&gt; parameter takes care of &lt;em&gt;cleaning the cache directory removing obsolete binary packages.&lt;&#x2F;em&gt; Obsolete binary packages? Good riddance! I was surprised this to learn that solely this step freed up almost half of my used root partition disk space.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-removing-orphaned-packages&quot;&gt;2. Removing orphaned packages&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;shell&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-shell &quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span&gt;# xbps-remove -yo
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here the same &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;man.voidlinux.org&#x2F;xbps-remove.1#o,&quot;&gt;man page&lt;&#x2F;a&gt; tells us that the &lt;code&gt;-o&lt;&#x2F;code&gt; parameter takes care of &lt;em&gt;removing installed package orphans that were installed automatically (as dependencies) and are not currently dependencies of any installed package.&lt;&#x2F;em&gt; As before, good riddance!&lt;&#x2F;p&gt;
&lt;h3 id=&quot;3-purging-old-unused-kernels&quot;&gt;3. Purging old, unused kernels&lt;&#x2F;h3&gt;
&lt;p&gt;This one is interesting. While I knew about the circumstance that the people behind Void had developed their own package management ecosystem, I hadn’t fully realized there were other utilities that came along with the upstream Void installation which were there for me to manage my beloved OS. So, apparently, one of these is a &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;void-linux&#x2F;void-packages&#x2F;blob&#x2F;master&#x2F;srcpkgs&#x2F;base-files&#x2F;files&#x2F;vkpurge&quot;&gt;shell script&lt;&#x2F;a&gt; name &lt;code&gt;vkpurge&lt;&#x2F;code&gt;, I must assume as a short name for &lt;code&gt;Void&#x27;s Kernel purging&lt;&#x2F;code&gt; tool. I like this type of naming heavily implying its functionality.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;shell&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-shell &quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span&gt;# vkpurge rm all
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It performed as expected. Old kernel files (and modules?) were indeed purged and freed up even more disk space. I should add that this step is optional as it is always useful to have some old kernels at hand when things hit the fan (which for me, they haven’t in a very, very long time).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;result&quot;&gt;Result&lt;&#x2F;h2&gt;
&lt;p&gt;I couldn’t be happier.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;shell&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-shell &quot;&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;&lt;span&gt;$ df -H
&lt;&#x2F;span&gt;&lt;span&gt;Filesystem      Size  Used Avail Use% Mounted on
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;dev&#x2F;nvme0n1p3  138G   45G   93G  33% &#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;renewal-of-faith&quot;&gt;Renewal of faith&lt;&#x2F;h2&gt;
&lt;p&gt;Overall, why am I even writing this if some other fellow engineer already figured this out? Simply, because I would therefore be able to explain why I have enjoyed my journey with Void as my go-to Linux distribution. It keeps things simple. Some well-documented utilities. As simple that a simple Brave search suffices to find the answer to my problems.&lt;&#x2F;p&gt;
&lt;p&gt;This very aspect of Void is worthwhile highlighing. I remember more arcane Linux distributions that had me in their grip in figuring things out. Many Googles searches were necessary and even more trial and errors attempts to get simple things fixed.&lt;&#x2F;p&gt;
&lt;p&gt;Now back to my Monday morning.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;Painting in header image is “Seaside” by Aleksandr Deyneka&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</description>
      </item>
      <item>
          <title>All beginning is Haskell</title>
          <pubDate>Mon, 06 Mar 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://raskell.io/articles/all-beginning-is-haskell/</link>
          <guid>https://raskell.io/articles/all-beginning-is-haskell/</guid>
          <description xml:base="https://raskell.io/articles/all-beginning-is-haskell/">&lt;h2 id=&quot;the-beauty-of-mathematics&quot;&gt;The beauty of mathematics&lt;&#x2F;h2&gt;
&lt;p&gt;Mathematics is often considered beautiful because it provides a way to describe and understand the world in a way that is precise, elegant, and abstract. Mathematics can be seen as a language that allows us to describe complex phenomena and patterns in a way that is independent of the particular objects or situations involved. This abstract quality of mathematics is what makes it so powerful and beautiful.&lt;&#x2F;p&gt;
&lt;p&gt;Mathematics can also be considered beautiful because of its ability to reveal unexpected connections and relationships between seemingly disparate areas of study. By using the language of mathematics to describe complex phenomena, we are able to identify deep and fundamental connections between seemingly unrelated areas of study, revealing the underlying structure and order in the natural world.&lt;&#x2F;p&gt;
&lt;p&gt;As someone who always was drawn by this type of mathematical beauty, I also was naturally drawn to Haskell due to its roots in mathematical theory since the first time I read about Haskell. Haskell was created by a group of researchers who were interested in creating a language that was as pure as possible. The language was designed to be purely functional, meaning that all computations are performed through the evaluation of functions. This approach allows Haskell programs to be more concise and easier to reason about than programs written in imperative languages like Java or C++. As a language that emphasizes purity and immutability, Haskell is particularly well-suited to applications in mathematics, data analysis, and other areas where correctness and maintainability are critical.&lt;&#x2F;p&gt;
&lt;p&gt;In addition to its mathematical roots, Haskell’s focus on purity and immutability also appealed to me as a programmer. As someone who has worked on projects with large codebases, I understand the importance of maintainability and the challenges that can arise when code is difficult to reason about or modify. By focusing on pure functions and immutability, Haskell reduces the potential for bugs and makes it easier to modify code without introducing new problems.&lt;&#x2F;p&gt;
&lt;p&gt;In this blog post, I will provide an introduction to Haskell and explore how its focus on pure functions and easy refactoring can make code maintenance easier. I’ll also provide some interesting code snippets to help illustrate Haskell’s unique approach to programming. Whether you’re a seasoned developer or a math enthusiast like myself, I hope that this post will give you a deeper appreciation for the beauty and power of Haskell.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mister-curry-haskell&quot;&gt;Mister Curry Haskell&lt;&#x2F;h2&gt;
&lt;p&gt;Haskell is named after the logician Haskell Curry, who was a pioneer in the field of mathematical logic and contributed significantly to the development of the lambda calculus. The lambda calculus is a mathematical notation system for expressing computation that is closely related to functional programming.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell was developed in the late 1980s by a group of researchers, including Simon Peyton Jones, Philip Wadler, and others, who were interested in creating a purely functional programming language that was inspired by the lambda calculus. They named the language after Haskell Curry as a tribute to his contributions to mathematical logic.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell’s focus on purity and immutability is closely related to the lambda calculus, which is based on the idea of functions as first-class citizens. In Haskell, functions are treated as values that can be passed around, composed, and evaluated just like any other data type. This approach allows Haskell programs to be more concise and easier to reason about than programs written in imperative languages like Java or C++.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell also incorporates many features from other functional programming languages like ML and Lisp, as well as concepts from category theory and other branches of mathematics. The language’s sophisticated type system, which includes type inference, type classes, and higher-kinded types, is one of its most distinctive and powerful features.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-lambda-is-the-new-alpha&quot;&gt;The Lambda is the new Alpha&lt;&#x2F;h2&gt;
&lt;p&gt;Haskell is closely related to the lambda calculus, which is a mathematical notation system for expressing computation. The lambda calculus was developed in the early 20th century by mathematician Alonzo Church as a way to formalize the notion of computability.&lt;&#x2F;p&gt;
&lt;p&gt;The lambda calculus consists of three basic elements: variables, functions, and applications. Variables represent values, functions represent computations, and applications represent the act of applying a function to an argument. For example, the function $ f(x) = x + 1 $ could be represented in the lambda calculus as the expression $ (λx.x + 1) $ .&lt;&#x2F;p&gt;
&lt;p&gt;Haskell was developed in the late 1980s by a group of researchers, including Simon Peyton Jones, Philip Wadler, and others, who were interested in creating a purely functional programming language that was inspired by the lambda calculus. As mentioned above, they named the language after Haskell Curry as a tribute to his contributions to mathematical logic.&lt;&#x2F;p&gt;
&lt;p&gt;Like the lambda calculus, Haskell is based on the principles of functional programming, which emphasize the use of pure functions and immutable data structures. In Haskell, functions are first-class citizens that can be passed around and composed just like any other data type. This allows Haskell programmers to create powerful abstractions and write code that is more modular and reusable than in imperative languages like C++ or Java.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell’s type system is also inspired by the lambda calculus, and includes features like type inference, type classes, and higher-kinded types. This allows Haskell programmers to write code that is both statically typed and expressive, reducing the potential for errors while still allowing for elegant and concise code.&lt;&#x2F;p&gt;
&lt;p&gt;Here’s an example of a lambda calculus expression that represents the addition of two numbers:&lt;&#x2F;p&gt;
&lt;p&gt;$$ (λx.λy.x + y) $$&lt;&#x2F;p&gt;
&lt;p&gt;In this expression, λx represents a function that takes an input x, and λy represents a function that takes an input y. The expression x + y represents the sum of x and y.&lt;&#x2F;p&gt;
&lt;p&gt;To use this expression to add two numbers, we apply it to two arguments:&lt;&#x2F;p&gt;
&lt;p&gt;$$ (λx.λy.x + y) 3 4 $$&lt;&#x2F;p&gt;
&lt;p&gt;In this case, the expression is applied to the arguments 3 and 4, resulting in the following computation:&lt;&#x2F;p&gt;
&lt;p&gt;$$ (λy.3 + y) 4 $$&lt;&#x2F;p&gt;
&lt;p&gt;In this expression, the function λx has been replaced with the value 3, resulting in a new function that takes an input y and adds it to 3. This function is then applied to the argument 4, resulting in the value 7.&lt;&#x2F;p&gt;
&lt;p&gt;This example demonstrates the basic principles of the lambda calculus, where functions are used to represent computations and can be composed and applied in a way that is similar to arithmetic operations. These principles form the basis of functional programming, and have been influential in the development of languages like Haskell, which was designed to be closely aligned with the lambda calculus.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;one-type-system-to-rule-them-all&quot;&gt;One Type System to rule them all&lt;&#x2F;h2&gt;
&lt;p&gt;ML (Meta Language) is considered a precursor to Haskell because it is a functional programming language that shares many of the same concepts and ideas. Like Haskell, ML is strongly typed and supports type inference, pattern matching, and higher-order functions. ML was developed in the 1970s by Robin Milner and others as a tool for writing software that could reason about mathematical objects and proofs. It was initially designed as a metalanguage for describing programming languages, but quickly evolved into a full-fledged programming language in its own right.&lt;&#x2F;p&gt;
&lt;p&gt;One of the key features of ML that influenced the development of Haskell is its support for algebraic data types. Algebraic data types allow programmers to define complex data structures by combining simpler types in various ways, using constructs like sums, products, and variants. This allows for a high degree of expressiveness and modularity in programming. Haskell also inherits many other features from ML, such as its focus on purity, immutability, and higher-order functions. ML also introduced the concept of type inference, which allows type information to be inferred automatically from the code, reducing the need for explicit type annotations.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell’s type system is based on the Hindley-Milner type system, which was first introduced in the ML programming language in the 1970s. The Hindley-Milner type system is a type inference algorithm that can deduce the types of expressions in a program without the need for explicit type annotations. In Haskell, the Hindley-Milner type system has been extended and refined to include additional features such as type classes, higher-kinded types, and generalized algebraic data types. These extensions make Haskell’s type system more expressive and flexible than the original Hindley-Milner type system in ML.&lt;&#x2F;p&gt;
&lt;p&gt;Type classes are a key feature of Haskell’s type system that allow programmers to define common behavior for a set of types. For example, the &lt;code&gt;Eq&lt;&#x2F;code&gt; type class defines the notion of equality for a given type, while the Ord type class defines the notion of order. Type classes provide a powerful mechanism for creating modular and reusable code.&lt;&#x2F;p&gt;
&lt;p&gt;Higher-kinded types are another extension to Haskell’s type system that allow for more complex and abstract types. In essence, higher-kinded types are types that take other types as arguments, allowing for a greater degree of generality and abstraction in programming.&lt;&#x2F;p&gt;
&lt;p&gt;Generalized algebraic data types (GADTs) are a further refinement of algebraic data types that allow for more precise control over the types of data in a program. GADTs allow programmers to specify more specific constraints on the types of data that can be manipulated, leading to more robust and maintainable code.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell’s type system builds on the foundations laid by the Hindley-Milner type system in ML, but extends and refines it to include additional features that make Haskell’s type system more expressive and flexible. By providing a powerful and expressive type system, Haskell makes it easier for programmers to write correct and maintainable code.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;eli5-what-is-haskell-again&quot;&gt;ELI5: What is Haskell again?&lt;&#x2F;h2&gt;
&lt;p&gt;Haskell is a functional programming language that was first developed in the late 1980s. It is named after the logician Haskell Curry and is designed to be purely functional, meaning that all computations are performed through the evaluation of functions. This approach allows Haskell programs to be more concise and easier to reason about than programs written in imperative languages like Java or C++.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell is a statically-typed language, which means that the type of every expression is known at compile time. This allows the compiler to catch many errors before the program is even run, making it easier to write correct code. Haskell also has a sophisticated type system that allows for powerful abstractions and code reuse.&lt;&#x2F;p&gt;
&lt;p&gt;One of the most distinctive features of Haskell is its laziness. This means that expressions are only evaluated when they are needed, allowing for efficient use of resources and the creation of infinite data structures.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;getting-started-with-haskell&quot;&gt;Getting started with Haskell&lt;&#x2F;h2&gt;
&lt;p&gt;To get started with Haskell, you’ll need to install the GHC compiler and an editor or IDE that supports Haskell development. Once you have these tools set up, you can start writing Haskell code!&lt;&#x2F;p&gt;
&lt;p&gt;Let’s start with a simple “Hello, world!” program:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;:: IO &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;main &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; putStrLn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Hello, world!&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This program defines a main function that prints the string “Hello, world!” to the console. The :: operator is used to specify the type of the main function, which in this case is IO (). The IO type represents actions that interact with the outside world, like reading from or writing to files.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;from-pure-functions-to-easy-refactoring&quot;&gt;From pure functions to easy refactoring&lt;&#x2F;h2&gt;
&lt;p&gt;One of the key benefits of Haskell’s functional programming paradigm is that it makes it easy to write pure functions. A pure function is one that has no side effects and always returns the same result given the same input. This property makes pure functions easy to reason about and test.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s look at an example. Suppose we have a function that calculates the factorial of a number:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;factorial &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;:: Integer -&amp;gt; Integer
&lt;&#x2F;span&gt;&lt;span&gt;factorial n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; product [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span&gt;n]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function takes an Integer and returns its factorial. We can use it like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; factorial &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;5
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;120
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now suppose we want to optimize this function by memoizing the results. We can do this easily by using Haskell’s memoize function:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span&gt;Data.Function.Memoize (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;memoize&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;factorial &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;:: Integer -&amp;gt; Integer
&lt;&#x2F;span&gt;&lt;span&gt;factorial &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; memoize go
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    go &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;    go n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; n * factorial (n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The memoize function takes a function and returns a memoized version of it. This means that the function’s results are cached for future calls with the same arguments, improving performance.&lt;&#x2F;p&gt;
&lt;p&gt;Note that we didn’t need to change any of the code that calls the factorial function. This is because the function’s type signature didn’t change, and its behavior is still the same. This is an example of how easy refactoring can be in Haskell. By focusing on pure functions and immutability, Haskell makes it easy to modify code without introducing bugs or breaking existing functionality.&lt;&#x2F;p&gt;
&lt;p&gt;The absence of side effects and the use of pure functions can greatly aid in reasoning about code. By eliminating side effects and enforcing purity, it becomes much easier to reason about the behavior of a program and to understand its logic.&lt;&#x2F;p&gt;
&lt;p&gt;Here are some ways in which pure functions and the absence of side effects help with reasoning about code:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Predictability: Since pure functions do not have side effects, their behavior is entirely determined by their inputs. This makes it easy to predict the output of a pure function given a particular input, making it easier to reason about the behavior of the program as a whole.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Testability: Pure functions are easy to test because their behavior is entirely determined by their inputs. This makes it easy to write automated tests for pure functions, ensuring that they behave correctly and that any changes to their behavior can be caught early on.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Modularity: Pure functions are highly modular because they can be composed and reused in a variety of ways. Since they do not have side effects, they can be combined and used in a wide range of contexts without introducing unexpected behavior or side effects.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Reasoning about state: Pure functions make it easy to reason about the state of a program because they do not modify state. This makes it easier to understand the flow of data through a program and to reason about the relationships between different parts of the program.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The absence of side effects and the use of pure functions can greatly aid in reasoning about code by making it more predictable, testable, modular, and easier to understand. By enforcing purity and avoiding side effects, functional programming languages like Haskell can make it easier to reason about the behavior of complex programs, leading to more robust and maintainable code.&lt;&#x2F;p&gt;
&lt;p&gt;The use of pure functions and the absence of side effects can greatly improve the refactoring potential and code maintainability of a program.&lt;&#x2F;p&gt;
&lt;p&gt;Refactoring is the process of changing the structure of a program without changing its behavior. This can involve adding new features, improving performance, or making the code more modular and reusable. By using pure functions and avoiding side effects, it becomes much easier to refactor a program without introducing unexpected behavior or breaking existing functionality.&lt;&#x2F;p&gt;
&lt;p&gt;By using pure functions and avoiding side effects, functional programming languages like Haskell make it easier to refactor code without introducing bugs or unintended behavior. This improves code maintainability by making it easier to modify and update the codebase over time, reducing the risk of introducing new bugs or breaking existing functionality.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;purity-as-a-design-goal&quot;&gt;Purity as a design goal&lt;&#x2F;h2&gt;
&lt;p&gt;Pure functions are functions that have no side effects and always return the same result given the same input. In other words, a pure function’s output only depends on its input, and it doesn’t modify any external state or perform any I&#x2F;O operations.&lt;&#x2F;p&gt;
&lt;p&gt;This property is desirable for several reasons. First, pure functions are easier to reason about and test. Because they have no side effects, they always produce the same output given the same input, which makes them predictable and easier to verify. This can be especially important in mathematical or scientific contexts where correctness is critical.&lt;&#x2F;p&gt;
&lt;p&gt;Second, pure functions can be composed more easily than impure functions. Because pure functions have no side effects, they can be combined or nested in any order without affecting the final result. This makes it easier to write modular and reusable code that can be composed from smaller building blocks.&lt;&#x2F;p&gt;
&lt;p&gt;Third, pure functions can be more efficient than impure functions in certain contexts. Because pure functions are referentially transparent, meaning that their results depend only on their inputs, they can be memoized or cached to improve performance. This can be especially useful in recursive algorithms or in situations where expensive computations need to be repeated many times.&lt;&#x2F;p&gt;
&lt;p&gt;The concept of pure functions is closely related to mathematical theory, particularly the notion of functions in mathematical analysis.&lt;&#x2F;p&gt;
&lt;p&gt;In mathematics, a function is a mapping between two sets, where each element of the first set is associated with a unique element of the second set. For example, the function f(x) = x^2 is a mapping from the set of real numbers to the set of non-negative real numbers. Given any real number x, the function f(x) returns the square of that number.&lt;&#x2F;p&gt;
&lt;p&gt;Functions in mathematics are often defined in terms of their inputs and outputs, without reference to any external state or context. This is similar to the concept of pure functions in programming, which have no side effects and depend only on their input parameters.&lt;&#x2F;p&gt;
&lt;p&gt;The concept of referential transparency, which is central to the idea of pure functions in programming, also has a mathematical counterpart. In mathematical analysis, a function is said to be referentially transparent if it can be replaced by its value without changing the outcome of any other computations. For example, the function f(x) = x + 1 is referentially transparent, because it can be replaced by its value without affecting the outcome of any other computations.&lt;&#x2F;p&gt;
&lt;p&gt;The use of pure functions in programming can be seen as an extension of these mathematical concepts to the realm of software engineering. By designing programs in terms of pure functions, we can create software systems that are easier to reason about and test, more modular and reusable, and more efficient in certain contexts. This can lead to more robust and maintainable software systems that are better suited to the demands of modern computing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-side-effects-of-functional-purity&quot;&gt;The side-effects of functional purity&lt;&#x2F;h2&gt;
&lt;p&gt;The concepts of immutability, statelessness, higher-order functions, and lazy evaluation are closely related to the idea of pure functions in programming and are highly prominent in the advantages of a programming language like Haskell. By embracing these concepts, we can create software systems that are more robust, efficient, and maintainable.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Immutability&lt;&#x2F;strong&gt;: Immutability is the concept of not modifying data once it has been created. Immutable data structures are often used in functional programming, because they can make it easier to reason about the behavior of a program. In Haskell, many of the built-in data structures are immutable, including lists, tuples, and sets.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Statelessness&lt;&#x2F;strong&gt;: Statelessness refers to the concept of not maintaining any internal state between function calls. In other words, a stateless function depends only on its input parameters and has no side effects. Stateless functions are often used in functional programming, because they can make it easier to reason about the behavior of a program.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Higher-order functions&lt;&#x2F;strong&gt;: Higher-order functions are functions that take other functions as input parameters or return functions as output. Higher-order functions are often used in functional programming to create powerful abstractions and compose smaller functions into larger ones.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lazy evaluation&lt;&#x2F;strong&gt;: Lazy evaluation is the concept of delaying the evaluation of an expression until it is actually needed. In Haskell, expressions are evaluated only when their values are required to compute the final result of a program. This can lead to more efficient code, because expressions that are not needed are never evaluated.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;All of these concepts are closely related to pure functions, because they help enforce the properties of purity and immutability. By using immutable data structures and stateless functions, we can reduce the potential for side effects and create code that is more predictable and easier to reason about. Higher-order functions and lazy evaluation can also lead to more efficient and maintainable code by creating powerful abstractions and reducing the amount of unnecessary computation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nomad-as-monad&quot;&gt;Nomad as monad&lt;&#x2F;h2&gt;
&lt;p&gt;In a purely functional language like Haskell, functions that produce side effects like input&#x2F;output, state mutation, and exceptions are generally not considered pure. This is because they have the potential to produce different results for the same input, depending on the context in which they are executed.&lt;&#x2F;p&gt;
&lt;p&gt;To work with these effects in a purely functional way, Haskell uses monads to encapsulate the side effects and provide a way to compose and sequence them in a predictable way. For example, the IO monad is used to represent input&#x2F;output operations, while the State monad is used to represent stateful computations.&lt;&#x2F;p&gt;
&lt;p&gt;In the case of the IO monad, the monadic structure allows the input&#x2F;output operations to be performed in a predictable and composable way. The IO monad provides functions like &amp;gt;&amp;gt;= (pronounced “bind”) and &amp;gt;&amp;gt; (pronounced “then”) that allow input&#x2F;output operations to be sequenced and composed in a way that ensures their order of execution is well-defined.&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, the State monad provides a way to model stateful computations in a pure way. The State monad allows a function to compute a new state value based on an existing state value, without modifying the existing state value. This allows the state to be propagated through a series of function calls in a predictable and composable way.&lt;&#x2F;p&gt;
&lt;p&gt;Monads are therefore a fundamental concept in Haskell and are used to encapsulate effects, such as input&#x2F;output or state changes, in a purely functional way. Let’s take a look at a simple example that demonstrates the use of a monad in Haskell:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span&gt;Control.Monad.State
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;-- Define a function that uses the State monad to keep track of a counter
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;count &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;:: State Int Int
&lt;&#x2F;span&gt;&lt;span&gt;count &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= do
&lt;&#x2F;span&gt;&lt;span&gt;  n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;&amp;lt;-&lt;&#x2F;span&gt;&lt;span&gt; get
&lt;&#x2F;span&gt;&lt;span&gt;  put (n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  return n
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;-- Use the count function to increment a counter and retrieve its value
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;:: Int
&lt;&#x2F;span&gt;&lt;span&gt;result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; evalState count &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this example, we use the State monad to keep track of a counter. The State monad encapsulates stateful computations in a purely functional way, allowing us to write code that has side effects while still adhering to Haskell’s purity and immutability.&lt;&#x2F;p&gt;
&lt;p&gt;The count function uses the State monad to read the current value of the counter, increment it by 1, and return its original value. This is achieved using the get, put, and return functions provided by the State monad.&lt;&#x2F;p&gt;
&lt;p&gt;The result variable uses the evalState function to run the count function with an initial state of 0. This results in the counter being incremented by 1 and its value being returned, which is then assigned to the result variable.&lt;&#x2F;p&gt;
&lt;p&gt;This example demonstrates how monads can be used to encapsulate side effects in a purely functional way, making it easier to reason about and maintain code. The State monad is just one example of a monad in Haskell, and there are many others, such as the IO monad for input&#x2F;output operations and the Maybe monad for handling optional values.&lt;&#x2F;p&gt;
&lt;p&gt;By using monads, Haskell programmers can write code that has side effects in a way that is consistent with the language’s focus on purity and immutability. This can lead to more robust and maintainable software systems that are easier to test and modify over time.&lt;&#x2F;p&gt;
&lt;p&gt;In mathematics, a monad is a structure that describes a certain kind of algebraic operation. Specifically, a monad is a triple (T, η, μ) consisting of:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A functor T that maps a category C to itself. This functor is often called the “monad functor”.&lt;&#x2F;li&gt;
&lt;li&gt;A natural transformation η from the identity functor on C to T. This natural transformation is called the “unit” of the monad.&lt;&#x2F;li&gt;
&lt;li&gt;A natural transformation μ from T∘T to T. This natural transformation is called the “multiplication” of the monad.
The monad structure is used in mathematics to describe a wide range of mathematical structures and operations, including algebraic structures like groups, rings, and fields, as well as more abstract structures like topological spaces and sheaves.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In computer science, monads are used as a programming construct that provides a way to encapsulate computation and control side effects in a purely functional way. In this context, a monad is typically defined as a type constructor that provides a way to combine and sequence operations in a way that is both composable and predictable. Monads are often used in functional programming languages like Haskell to model a wide range of effects, including input&#x2F;output, state, and exceptions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-everyone-should-learn-a-haskell-for-a-great-good&quot;&gt;Why everyone should learn a Haskell for a great good&lt;&#x2F;h2&gt;
&lt;p&gt;One of the benefits of learning Haskell is that it can help you develop a deeper understanding of programming concepts like recursion, higher-order functions, and lazy evaluation. Haskell’s focus on purity and immutability can also help you develop good programming habits that can be applied to other languages.&lt;&#x2F;p&gt;
&lt;p&gt;However, despite its many advantages, Haskell is not as commonly used as other programming languages like Java or Python. This is due in part to its steep learning curve and the fact that it is less widely taught in universities and other educational institutions. Haskell also has a smaller community of developers than some other languages, which can make it harder to find resources and support.&lt;&#x2F;p&gt;
&lt;p&gt;Despite these challenges, there are many reasons to learn and use Haskell. For example, Haskell’s focus on purity and immutability can lead to more robust and maintainable code. The language’s type system can also catch many errors at compile time, reducing the potential for bugs. In addition, Haskell’s focus on functional programming can help you develop good programming habits that can be applied to other languages. Here are some of the reasons why it is worthwhile to learn Haskell:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Learning Haskell can help you develop a deeper understanding of programming concepts like recursion, higher-order functions, and lazy evaluation. Haskell’s focus on purity and immutability can also help you develop good programming habits that can be applied to other languages.&lt;&#x2F;li&gt;
&lt;li&gt;Haskell’s sophisticated type system can catch many errors at compile time, reducing the potential for bugs. This can lead to more robust and maintainable code.&lt;&#x2F;li&gt;
&lt;li&gt;Haskell’s focus on purity and immutability can lead to more elegant and concise code that is easier to reason about and test.&lt;&#x2F;li&gt;
&lt;li&gt;Haskell is a powerful tool for data analysis, machine learning, and other computational tasks that involve complex algorithms and mathematical models.&lt;&#x2F;li&gt;
&lt;li&gt;Haskell has a small but passionate community of developers who are constantly pushing the boundaries of what is possible with functional programming.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;One of the key benefits of Haskell’s functional programming paradigm is that it makes it easy to write maintainable code. By focusing on pure functions and immutability, Haskell reduces the potential for bugs and makes it easier to modify code without introducing new problems.&lt;&#x2F;p&gt;
&lt;p&gt;The use of pure functions means that code is easier to reason about and test. Pure functions have no side effects and always return the same result given the same input. This property makes them easy to test and reduces the potential for bugs. In addition, pure functions are composable, meaning that they can be combined to create more complex functions. This allows for the creation of highly modular and reusable code, which can simplify the process of maintaining and updating code over time.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell’s emphasis on immutability also contributes to code maintainability. Immutable data structures are less prone to bugs and can be easier to reason about than mutable ones. Immutable data structures also encourage a functional style of programming, which can lead to more concise and elegant code.&lt;&#x2F;p&gt;
&lt;p&gt;Ultimately, Haskell’s focus on functional programming, immutability, and easy refactoring makes it an ideal choice for building maintainable code. By reducing the potential for bugs and making it easier to modify code over time, Haskell can help developers create software that is robust and easy to maintain.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;references-and-further-reading&quot;&gt;References and further reading&lt;&#x2F;h2&gt;
</description>
      </item>
      <item>
          <title>My OpenBSD journey: Getting it virtualized with libvirt (1)</title>
          <pubDate>Mon, 06 Feb 2023 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://raskell.io/articles/my-openbsd-journey-getting-it-virtualized-with-libvirt-1/</link>
          <guid>https://raskell.io/articles/my-openbsd-journey-getting-it-virtualized-with-libvirt-1/</guid>
          <description xml:base="https://raskell.io/articles/my-openbsd-journey-getting-it-virtualized-with-libvirt-1/">&lt;h2 id=&quot;void-linux-as-my-daily-driver&quot;&gt;Void Linux as my daily driver&lt;&#x2F;h2&gt;
&lt;p&gt;Around six months ago, I decided to ditch my long in the tooth Arch-based setup on my belovest Thinkpad X1 Carbon. I’ve been very loyal over the years, and almost came to belive that Arch will be a constant in my adult life. While I kept up with upcoming technologies, I somehow lost track of the ever so diversifying landscape of Linux distributions. It took me a while of constantly coming across a generically named reference to what seemed to be yet another Linux distribution. That outwardly generic sounding name, &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;voidlinux.org&#x2F;&quot;&gt;Void Linux&lt;&#x2F;a&gt;, kept poking my curiosity by supposedly feeling like Arch Linux in the old days, while sharing some substantial DNA with the BSD operating systems. Yet, that’s another story I might tell another day, but to remain brief, the BSDs, in particular the infamous OpenBSD with its quite infamous lead developer Theo De Raadt, always were what I considered the endgame. The holy grail of Unix operating systems, so did I think over the decades, FreeBSD, NetBSD and OpenBSD, have always been on my personal radar and I felt I had to earn the intellectual capacity to be able to properly put them at use one day. Last year, when I made the (almost painless) switch from Arch Linux to Void Linux, the simplicity and especially the barebone experience of Void reignited the fascination and the admiration I always had for the BSD operating systems and their philosophy.&lt;&#x2F;p&gt;
&lt;p&gt;While I could write (and definitely will in the near future) about how my journey onto Void Linux and how it has been so far, I preferred to write down, in some like diary, and document every step on how one can approach and ultimately use &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.openbsd.org&#x2F;&quot;&gt;OpenBSD&lt;&#x2F;a&gt; in 2023. Big disclaimer, I’ve yet to install OpenBSD on some baremetal server I ordered some days ago, but dabbled around in the meantime with OS-level virtualization in order to get it running. That’s what brings me to &lt;em&gt;libvirt&lt;&#x2F;em&gt; and my surprise to learn that I wouldn’t need some full-fledged virtualization solution like the ones offered by VirtualBox or VMWare to efficiently run a virtualized OpenBSD machine. So, ok, let’s recap, so far we got the following bill of materials:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Void Linux as the host system&lt;&#x2F;li&gt;
&lt;li&gt;OpenBSD to be virtualized on that host system&lt;&#x2F;li&gt;
&lt;li&gt;libvirt as the glue that makes virtualization feel like black magic&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;from-void-to-openbsd&quot;&gt;From Void to OpenBSD&lt;&#x2F;h3&gt;
&lt;p&gt;Before I tell you more about the history of how things went down while setting up OpenBSD, let me give you some basic notions about both Void Linux, being one out of many Linux distributions for the sake of simplicity representing them all as it ended up being my distribution of choice, and OpenBSD. As already mentioned earlier, Void Linux and OpenBSD are both Unix-like operating systems, but they feature enough differences to make them noteworthy. Here are a few similarities and differences between the two:&lt;&#x2F;p&gt;
&lt;p&gt;What is similar:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Both are free and open-source operating systems.&lt;&#x2F;li&gt;
&lt;li&gt;Both use a package manager for software management. Void Linux uses XBPS, while OpenBSD uses pkg_add.&lt;&#x2F;li&gt;
&lt;li&gt;Both prioritize security and stability in their development and design.&lt;&#x2F;li&gt;
&lt;li&gt;Both feature a version control based package repository, meaning that changes in build definition are managed by pull requests from users.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;What is different:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;License: Void Linux is licensed under the MIT License, while OpenBSD is licensed under the ISC License.&lt;&#x2F;li&gt;
&lt;li&gt;Philosophy: OpenBSD prioritizes security and privacy, while Void Linux prioritizes simplicity and modularity.&lt;&#x2F;li&gt;
&lt;li&gt;Package Management: Void Linux uses a binary package manager (XBPS), while OpenBSD uses a source-based package manager (pkg_add).&lt;&#x2F;li&gt;
&lt;li&gt;Package Repository: Void Linux has a large and diverse repository, while OpenBSD has a smaller and more curated repository.&lt;&#x2F;li&gt;
&lt;li&gt;Init System: Void Linux uses runit as its init system, while OpenBSD uses rc. None uses the infamous systemd init system.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;what-is-openbsd-in-a-nutshell&quot;&gt;What is OpenBSD in a nutshell&lt;&#x2F;h2&gt;
&lt;p&gt;OpenBSD is a free and open-source operating system that focuses on security, standardization, and robustness. It is based on the Berkeley Software Distribution (BSD) Unix operating system and is developed by a global community of volunteers. OpenBSD aims to provide a secure platform for both personal and enterprise use by implementing strong security features, including access control mechanisms, encryption, and auditing.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Theo_de_Raadt&quot;&gt;Theo de Raadt&lt;&#x2F;a&gt; is the founder and lead developer of OpenBSD. His main objective with OpenBSD is to create a secure operating system that is free from backdoors, vulnerabilities, and other security weaknesses. He is committed to auditing the source code of the operating system and third-party software included with it, to identify and remove any potential security risks. De Raadt is also dedicated to improving the overall quality of the codebase and ensuring compatibility with a wide range of hardware and software.&lt;&#x2F;p&gt;
&lt;p&gt;What makes OpenBSD really special and stand out is that is developed a suite of tools that got adopted by other OSs like Linux, macOS or even Windows. One of the most famous instances of such adoption is the now de facto standard openssh suite. It actually emerged from within the development circle of the OpenBSD project. OpenBSD also implemented a wide range of OS features that are by now considered staples among other OSs, things like Linux-based OS-level containerization done via the means of cgroups, something that OpenBSD already pioneered and solved with a different spin many years before Linux with pledge and unveil. Go check out &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;why-openbsd.rocks&#x2F;fact&#x2F;freezero&#x2F;&quot;&gt;Why OpenBSD rocks&lt;&#x2F;a&gt; to get a feel what makes OpenBSD so unique and interesting.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;virtualization-with-libvirt&quot;&gt;Virtualization with libvirt&lt;&#x2F;h3&gt;
&lt;p&gt;So now, let’s get back to our virtualization endeavour where we would like to virtualize OpenBSD on a Void Linux installation. If you happen to be using another Linux distribution, most of the individual steps would be very similar. That brings me to the next technology we should explain a bit more here, and that is libvirt.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;libvirt.org&#x2F;&quot;&gt;libvirt&lt;&#x2F;a&gt; is an open-source virtualization management library that provides a simple and unified API for managing virtualization technologies, including KVM, QEMU, Xen, and others. It aims to simplify the process of creating, managing, and migrating virtual machines, storage, and networks, and to make it easier for administrators to manage virtual environments.&lt;&#x2F;p&gt;
&lt;p&gt;To virtualize an operating system like OpenBSD with libvirt, you need to follow these steps:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Install libvirt and the virtualization technology you want to use, such as KVM.&lt;&#x2F;li&gt;
&lt;li&gt;Download the OpenBSD iso file and place it in a location accessible by libvirt.&lt;&#x2F;li&gt;
&lt;li&gt;Create a new virtual machine in libvirt with the OpenBSD ISO as the installation media. This can be done through the command line or using a graphical user interface such as virt-manager.&lt;&#x2F;li&gt;
&lt;li&gt;Configure the virtual machine, including the amount of memory, CPU, and disk space, to meet the requirements of OpenBSD.&lt;&#x2F;li&gt;
&lt;li&gt;Start the virtual machine and install OpenBSD as you would on a physical machine.&lt;&#x2F;li&gt;
&lt;li&gt;Once the installation is complete, you can configure the virtual network, storage, and other settings as required.&lt;&#x2F;li&gt;
&lt;li&gt;Finally, you can use the libvirt API or the command line to manage and control the virtual machine, including starting, stopping, migrating, and snapshotting.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;step-by-step-guide&quot;&gt;Step-by-step guide&lt;&#x2F;h3&gt;
&lt;p&gt;Let’s first install the &lt;code&gt;libvirt&lt;&#x2F;code&gt; package and some related packages which we need in order to connect via VNC. The VNC will provide us with the possibility to use the graphical interface of the running OpenBSD instance.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; sudo xbps-install -S dbus qemu libvirt virt-manager virt-viewer tigervnc
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, we need to add our user, in my case &lt;code&gt;raskell&lt;&#x2F;code&gt;, to the &lt;code&gt;libvirt&lt;&#x2F;code&gt; group which got simultanously created with the installation of libvirt.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; sudo usermod -aG libvirt raskell
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;OpenBSD features a release cycle of six months. We would need to update our system every six month to keep up with the latest packages. During a given release, only security and bug fix patches are applied to the curated packages maintained by pkg_add. Therefore, in February 2023, we’re using the &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.openbsd.org&#x2F;72.html&quot;&gt;OpenBSD 7.2&lt;&#x2F;a&gt; release version. As I’m living in Switzerland, I chose to pull the iso image from a Swiss mirror, in this case from &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;mirror.ungleich.ch&#x2F;pub&#x2F;OpenBSD&#x2F;7.2&#x2F;&quot;&gt;&lt;code&gt;mirror.ungleich.ch&#x2F;pub&#x2F;OpenBSD&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; (check what mirror is closest to you to get the best download rate).&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# cd &#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;boot&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# sudo wget https:&#x2F;&#x2F;mirror.ungleich.ch&#x2F;pub&#x2F;OpenBSD&#x2F;7.2&#x2F;amd64&#x2F;install72.iso
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;--2023-01-12&lt;&#x2F;span&gt;&lt;span&gt; 20:48:15--  https:&#x2F;&#x2F;mirror.ungleich.ch&#x2F;pub&#x2F;OpenBSD&#x2F;7.2&#x2F;amd64&#x2F;install72.iso
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;Resolving&lt;&#x2F;span&gt;&lt;span&gt; mirror.ungleich.ch (mirror.ungleich.ch)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; 2a0a:e5c0:2:2:400:c8ff:fe68:bef3, 185.203.114.135
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;Connecting&lt;&#x2F;span&gt;&lt;span&gt; to mirror.ungleich.ch (mirror.ungleich.ch)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;2a0a:e5c0:2:2:400:c8ff:fe68:bef3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;:443...&lt;&#x2F;span&gt;&lt;span&gt; connected.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;HTTP&lt;&#x2F;span&gt;&lt;span&gt; request sent, awaiting response... 200 OK
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;Length:&lt;&#x2F;span&gt;&lt;span&gt; 583352320 (556M) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;[application&#x2F;octet-stream]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;Saving&lt;&#x2F;span&gt;&lt;span&gt; to: ‘install72.iso.1’
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;install72.iso.1&lt;&#x2F;span&gt;&lt;span&gt;                      100&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;%[&lt;&#x2F;span&gt;&lt;span&gt;====================================================================&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt; 556.33M  7.11MB&#x2F;s    in 77s     
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;2023-01-12&lt;&#x2F;span&gt;&lt;span&gt; 20:49:33 (7.19 MB&#x2F;s) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span&gt; ‘install72.iso.1’ saved &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;583352320&#x2F;583352320&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;sudo&lt;&#x2F;span&gt;&lt;span&gt; wget https:&#x2F;&#x2F;mirror.ungleich.ch&#x2F;pub&#x2F;OpenBSD&#x2F;7.2&#x2F;amd64&#x2F;SHA256
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;--2023-01-12&lt;&#x2F;span&gt;&lt;span&gt; 20:47:38--  https:&#x2F;&#x2F;mirror.ungleich.ch&#x2F;pub&#x2F;OpenBSD&#x2F;7.2&#x2F;amd64&#x2F;SHA256
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;Resolving&lt;&#x2F;span&gt;&lt;span&gt; mirror.ungleich.ch (mirror.ungleich.ch)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span&gt; 2a0a:e5c0:2:2:400:c8ff:fe68:bef3, 185.203.114.135
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;Connecting&lt;&#x2F;span&gt;&lt;span&gt; to mirror.ungleich.ch (mirror.ungleich.ch)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;2a0a:e5c0:2:2:400:c8ff:fe68:bef3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;:443...&lt;&#x2F;span&gt;&lt;span&gt; connected.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;HTTP&lt;&#x2F;span&gt;&lt;span&gt; request sent, awaiting response... 200 OK
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;Length:&lt;&#x2F;span&gt;&lt;span&gt; 1992 (1.9K) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;[application&#x2F;octet-stream]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;Saving&lt;&#x2F;span&gt;&lt;span&gt; to: ‘SHA256.1’
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;SHA256.1&lt;&#x2F;span&gt;&lt;span&gt;                             100&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;%[&lt;&#x2F;span&gt;&lt;span&gt;====================================================================&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt;   1.95K  --.-KB&#x2F;s    in 0s      
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;2023-01-12&lt;&#x2F;span&gt;&lt;span&gt; 20:47:39 (742 MB&#x2F;s) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;-&lt;&#x2F;span&gt;&lt;span&gt; ‘SHA256.1’ saved &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;1992&#x2F;1992&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# grep install63.iso SHA256 &amp;gt; &#x2F;tmp&#x2F;x
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# sha256sum -c &#x2F;tmp&#x2F;x
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;# rm &#x2F;tmp&#x2F;x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Before we can start the virtualization server and get running our OpenBSD instance, we need to define the configuraiton on how to virtualize and ultimately boot the system with. This is done with &lt;code&gt;virt-install&lt;&#x2F;code&gt;. Noteworthy here is that we &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.qemu.org&#x2F;&quot;&gt;QEMU&lt;&#x2F;a&gt; as our emulation solution of choice, we allocate up to 4GB of RAM and 4 CPU cores to the machine.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; sudo virt-install &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;\
&lt;&#x2F;span&gt;&lt;span&gt;      --name&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt;openbsd &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;\
&lt;&#x2F;span&gt;&lt;span&gt;      --virt-type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt;qemu &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;\
&lt;&#x2F;span&gt;&lt;span&gt;      --memory&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt;2048,maxmemory=4096 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;\
&lt;&#x2F;span&gt;&lt;span&gt;      --vcpus&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt;2,maxvcpus=4 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;\
&lt;&#x2F;span&gt;&lt;span&gt;      --cpu host &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;\
&lt;&#x2F;span&gt;&lt;span&gt;      --os-variant&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt;openbsd7.0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;\
&lt;&#x2F;span&gt;&lt;span&gt;      --cdrom&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;boot&#x2F;install72.iso &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;\
&lt;&#x2F;span&gt;&lt;span&gt;      --network&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt;bridge=virbr0,model=virtio &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;\
&lt;&#x2F;span&gt;&lt;span&gt;      --graphics&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt;vnc &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;\
&lt;&#x2F;span&gt;&lt;span&gt;      --disk path=&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;openbsd.qcow2,size=40,bus=virtio,format=qcow2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once, it is up and running, we can use a vnc solution to connect to the running machine. In this case, I chose &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.libvirt.org&#x2F;manpages&#x2F;virsh.html&quot;&gt;virsh&lt;&#x2F;a&gt; to do the job. virsh is a command-line interface tool for managing virtualization environments created with libvirt. It allows us to manage virtual machines, storage pools, and network interfaces, as well as other virtualization components, from the command line.&lt;&#x2F;p&gt;
&lt;p&gt;To establish a VNC connection with a running libvirt virtualized OpenBSD instance, you can use the following steps:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Start the virtual machine in libvirt: You can start the virtual machine using the virsh command &lt;strong&gt;&lt;code&gt;virsh start &amp;lt;vm-name&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;, where &lt;strong&gt;&lt;code&gt;&amp;lt;vm-name&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; is the name of the virtual machine you want to start.&lt;&#x2F;li&gt;
&lt;li&gt;Find the VNC display: Once the virtual machine is running, you can find the VNC display number for the virtual machine using the virsh command &lt;strong&gt;&lt;code&gt;virsh vncdisplay &amp;lt;vm-name&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Connect to the VNC display: You can connect to the VNC display using a VNC client, such as &lt;strong&gt;&lt;code&gt;vncviewer&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;, and specify the IP address of the host running the virtual machine and the VNC display number. For example, if the host’s IP address is &lt;strong&gt;&lt;code&gt;192.168.0.100&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt; and the VNC display number is &lt;strong&gt;&lt;code&gt;:0&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;, the command to connect would be &lt;strong&gt;&lt;code&gt;vncviewer 192.168.0.100:0&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Authenticate to the VNC server: You may need to enter a password to authenticate to the VNC server. The password is set when the virtual machine is created in libvirt.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;With these steps, you can establish a VNC connection with a running libvirt virtualized OpenBSD instance and interact with the virtual machine’s graphical user interface.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; virsh dumpxml openbsd &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;grep&lt;&#x2F;span&gt;&lt;span&gt; vnc
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;graphics type&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39;vnc&amp;#39; &lt;&#x2F;span&gt;&lt;span&gt;port&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39;5900&amp;#39; &lt;&#x2F;span&gt;&lt;span&gt;autoport&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39;yes&amp;#39; &lt;&#x2F;span&gt;&lt;span&gt;listen&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39;127.0.0.1&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like I did, most of you would like to interact with a graphical interface such as with X11. For that, we yet another tool, a so-called VNC viewer. A very simple implementation of such a vnc viewer is &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;tigervnc.org&#x2F;&quot;&gt;tigervnc&lt;&#x2F;a&gt; (simply install it with &lt;code&gt;$ sudo xbps-install -S tigervnc&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span&gt; sudo virsh --connect
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;qemu:&#x2F;&#x2F;&#x2F;system&lt;&#x2F;span&gt;&lt;span&gt; start openbsd
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;Domain &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;#39;openbsd&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt; started
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;{tbc}&lt;&#x2F;p&gt;
&lt;h2 id=&quot;references-and-further-reading&quot;&gt;References and further reading&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;voidlinux&#x2F;comments&#x2F;ghwvv5&#x2F;guide_how_to_setup_qemukvm_emulation_on_void_linux&#x2F;&quot;&gt;[Guide] how to setup QEMU&#x2F;KVM emulation on void linux | &#x2F;r&#x2F;voidlinux&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cyberciti.biz&#x2F;faq&#x2F;kvmvirtualization-virt-install-openbsd-unix-guest&#x2F;&quot;&gt;KVM virt-install: Install OpenBSD As Guest Operating System&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.skreutz.com&#x2F;posts&#x2F;autoinstall-openbsd-on-qemu&#x2F;&quot;&gt;Auto-install OpenBSD on QEMU | skreutz.com&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
      </item>
      <item>
          <title>Hello and outlook</title>
          <pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://raskell.io/articles/hello-and-outlook/</link>
          <guid>https://raskell.io/articles/hello-and-outlook/</guid>
          <description xml:base="https://raskell.io/articles/hello-and-outlook/">&lt;h2 id=&quot;hello-world&quot;&gt;Hello world&lt;&#x2F;h2&gt;
&lt;p&gt;Welcome to my tech blog! My name is Raffael and I am excited to share my rumings about the state of tech, open-source, and the life as a software developer with you.&lt;&#x2F;p&gt;
&lt;p&gt;In this first post, I wanted to introduce myself and explain what you can expect to find on this blog. I have been working in the tech industry for several years, and I have experience with a variety of technologies, programming languages, and operating systems. I have a strong interest in open-source software and the principles of open collaboration and sharing that underpin it. Also, I have a passion for tech hardware and the funtional restoration of discarded equipment. The freedom to express oneself with technology to make the world a more comfortable place is a strong focus of mine.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;outlook&quot;&gt;Outlook&lt;&#x2F;h2&gt;
&lt;p&gt;On this blog, I will be covering a wide range of topics related to technology in general, open-source, operating systems, programming, and tech hardware. Some of the things you can expect to find include:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;My dabblings into new and bleeding-edge technologies in general&lt;&#x2F;li&gt;
&lt;li&gt;My experience in using Linux, BSDs, and embedded operating systems&lt;&#x2F;li&gt;
&lt;li&gt;Exploration of new and exciting open-source projects&lt;&#x2F;li&gt;
&lt;li&gt;Discussion of the latest technology trends and innovations&lt;&#x2F;li&gt;
&lt;li&gt;Personal musings and insights into the tech industry&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I believe that technology has the power to change the world, and I am excited to be a small part of that change. I hope that this blog will serve as a valuable resource for anyone interested in technology, open-source, Linux, OpenBSD, and programming. I will be posting new content on a regular basis, so be sure to check back often.&lt;&#x2F;p&gt;
&lt;p&gt;In my next post, I will dive into a specific topic and share my knowledge and experience. I want to make sure that my readers will learn something new every time they visit my blog.&lt;&#x2F;p&gt;
&lt;p&gt;Thank you for visiting, and I look forward to connecting with you on social media or in real life.&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
